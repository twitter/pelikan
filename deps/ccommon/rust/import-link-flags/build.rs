// ccommon - a cache common library.
// Copyright (C) 2019 Twitter, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::env;
use std::fs::File;
use std::io::Read;
use std::path::Path;

/// Modify the flags into a format that rustc actually supports.
///
/// The problem here is that cmake prefers to pass full paths to
/// libraries whereas rustc wants us to split up link directories
/// and link libraries while possible. This method splits up any
/// paths in the command line that aren't already behind -l/-L
/// flags.
fn process_flags(flags: &str) {
    eprintln!("{}", flags);

    let flags = flags.split(" ");
    let mut prev = None;

    for flag in flags {
        if flag == "" {
            continue;
        }

        if let Some(prevflag) = prev {
            println!("cargo:rustc-flags={} {}", prevflag, flag);
            prev = None;
            continue;
        }

        if flag == "-l" || flag == "-L" {
            prev = Some(flag);
            continue;
        }

        if flag.starts_with("-l") || flag.starts_with("-L") {
            println!("cargo:rustc-flags={} {}", &flag[0..2], &flag[2..]);
            continue;
        }

        let path = Path::new(flag);
        // Don't assume anything about non-existant paths since they
        // might be generated by the build system later on.
        if !path.is_file() && path.exists() {
            panic!("Attempting to link to {} which is not a file", flag);
        }

        if let Some(parent) = path.parent() {
            println!("cargo:rustc-flags=-L {}", parent.display());
        }

        let filename = match path.file_name() {
            Some(filename) => filename,
            None => panic!("Attempted to link to a directory: {}", path.display()),
        };

        println!("cargo:rustc-flags=-l {}", Path::new(filename).display());
    }

    if let Some(prev) = prev {
        panic!("Unmatched '{}' flag", prev);
    }
}

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-env-changed=CCOMMON_LINK_FLAGS_FILE");

    if let Some(var) = env::var_os("CCOMMON_LINK_FLAGS_FILE") {
        let path = Path::new(&var);

        println!("cargo:rerun-if-changed={}", path.display());

        let mut file = match File::open(&path) {
            Ok(file) => file,
            Err(e) => panic!("Unable to open file {}: {}", path.display(), e),
        };

        let mut bytes = Vec::new();
        file.read_to_end(&mut bytes).expect("Failed to read file");

        let flags = String::from_utf8(bytes).expect("Build flags contained invalid utf8");
        process_flags(&flags);
    }
}
