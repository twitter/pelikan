The argument for setting a pointer to null after the resource it points to is released often raises two reasons: 1) it prevents double freeing, whose behavior is not determined; 2) it prevents the address from being treated as valid as the programs runs on, which can lead to data corruption and segfaults at some place far away from where the memory is freed.

The problem is definitely more obscure when resource pooling happens- now instead of freeing an object, we just reassign it sometime later. And it is very hard to detect bugs because we don't even get segfaults (or very rarely) in this case, instead data just look corrupted in weird ways.

In earlier versions of the library, I found my application (broadbill) prone to both mistakes- the same resource was returned to the pool twice, leading to corrupted linked listand occasionally segfaults, two pointers end up getting the same resource due to double "freeing", since with pooled resources the pointers are always pointing to valid memory, just that they are no longer entitled to use, the bugs manifested in weird ways.

However, I think there is value in allowing freeing an NULL pointer, why? Because it simplifies error handling greatly. If I'm setting up a some what complex data structure that contains pointers to other on-heap resources, often the allocation cascades from the top. So if at some point the initialization is aborted due to exceptional conditions, e.g. OOM, the program should clean up the resources already allocationed for the incomplete object. Now checking every member, to see if it is NULL is just visual clutter. There are legit cases where allowing free on a NULL pointer (which should result in noop), just like the C library does for free(), yields better style.

On the other hand, setting the caller to NULL seems to legitimately improve debuggability of the code. Especially when resource pools take away any call to free(), the only guard to runaway pointer is the pointer itself. Therefore, I consider it best practice to mandate all functions that reclaims resources (free, return to the resource pool) to take a pointer to the pointer we intend to free, and set the pointer to NULL afterwards. It is simply too easy for the caller (e.g. me) to forget doing that on their own.

Another problem with resource pooling is that the memory regions are dirty but not outright wrong in may cases, so the bugs are hidden for even longer. The solution to this is to make sure all pooled resources are properly reset before they are handed out to the caller.
