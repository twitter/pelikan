We will need interface for two types of events: I/O events (e.g. NIO), and timed events (stats, logs, ...)

The point of using events is to avoid polling and busy looping when there is a good chance that there is nothing to do. This is especially evident when a faster component (CPU) is interacting with a much slower one (disk, network), and when load is driven by external events that vary a lot. In systems design, events are often used to handle I/O, often in the form of reading from and writing to fds.
What this implies is that good abstraction should align the handling of events with I/O boundaries. For example, if we decide that stream is the abstraction that would handle communication details from higher level logic that deals with requests and data, then all event handling logic should stay with or below stream abstraction. For example, if writing to a fd would block (EAGAIN, EWOULDBLOCK), maybe due to a full buffer etc, we should create the event to retry the write in the stream module (or below). The higher level logic would know when and how much data is sent, but it should be their responsibility to update events, because that requires knowing some I/O detail.
